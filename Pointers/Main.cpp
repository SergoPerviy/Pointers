#include <iostream>

void myswap(int num1, int num2) {
	int tmp = num1;
	num1 = num2;
	num2 = tmp;
}
void pswap(int* pointer1, int* pointer2) {
	int tmp = *pointer1;
	*pointer1 = *pointer2;
	*pointer2 = tmp;
}

void psumarr(int arr[], const int lenght, int* var);

int main() {
	setlocale(LC_ALL, "Russian");
	int n{}, m{};

	//Указатели на переменные

	n = 7;
	std::cout << "n= " << n << std::endl;
	std::cout << "&n= " << &n << std::endl; // Вывод адреса переменной n с помощью операцими Амперсант.
	
	/*
	Указатель - переменная, созданная для хранения в себе адреса какой-либо области памяти. 
	Например, указатель может хранить адрес созданной ранее в программе переменной.
	*/

	int* pn = &n; // Создание указателя на область памяти типа int и присваивание ему значения в виде адреса n.
	std::cout << "pn= " << pn << std::endl; // Вывод значения указателя (шестнадцатиеричный адрес переменной n).
	std::cout << "*pn= " << *pn << std::endl; // Вывод значения n через разыменование указателя.

	/*
	Разыменование - операция, применяемая исключительно к указателям или адресам 
	памяти с целью обращения к тому участку памяти, на который они направлены.
	*/
	
	*pn = 15; // Изменение значения n через разыменование указателя.
	std::cout << "n= " << n << std::endl;
	std::cout << "---------------------------------\n";
	m = 42;
	std::cout << "m= " << m << std::endl;
	std::cout << "&m= " << &m << std::endl;
	pn = &m; // "Перенаправление" указателя на переменную m.
	std::cout << "pn= " << pn << std::endl;
	std::cout << "*pn= " << *pn << std::endl;
	int* pm = &m;
	std::cout << "pm= " << pm << std::endl;

	//Указатели и массивы
	
	const int size = 5;
	int arr[size]{ 30, 40, 50, 60 ,70 };
	int* parr2 = &arr[2];
	std::cout << parr2 << std::endl;
	std::cout << *parr2 << std::endl;
	parr2++;
	std::cout << parr2 << std::endl;
	std::cout << *parr2 << std::endl;

	/*
	Арифметика указателей - процесс перемещения указателя на другие соседние 
	участки памяти путем применения операции сложения и вычитания.
	
	Формула изменения адреса
	pointer + a = pointer + a * type_size (размер типа данных)
	Ограничение арифметики указателей:
	1. Нельзя делить и умножать значения указателей;
	2. Арфиметика указателей может работать только с целыми числами;
	3. Нелья складывать значения указателей между собой, но можно вычитать из указателя другой указатель.
	4. По отношению к указателям можно применять операцию сравнения (больше, меньше итд)
	*/

	parr2 = &arr[0];
	for (int i = 0; i < size; i++)
		std::cout << *(parr2 + i) << ' ';
	std::cout << std::endl;

	//Указатели и функции
	 
	n = 7; m = 15;
	std::cout << n << ' ' << m << std::endl;
	myswap(n, m); //не работает тк параметры это копии передаваемых значений.
	std::cout << n << ' ' << m << std::endl;
	pswap(&n, &m);
	std::cout << n << ' ' << m << std::endl;

	/*
	Области применения указателей:
	1. Реализация массивов в программировании;
	2. Косвенный доступ к элиментам за пределами их области видимости;
	3. Экономия памяти;
	4. Работа с динамической памятью;
	5. Реализация полиморфизма в ООП;
	6. Создание динамических структур данных.

	Размер указателей в байтах не зависит от типа данных, на который они направлены. Он зависит от архитектуры
	системы, для которой пишется приложение. Например, в ОС Windows с разрядностью x32 размер указателя - 4 байта.
	А с разрядностью х64 - 8 байт.
	*/

	//Задача 1. Сумма массива в указатель.

	std::cout << "Задача 1. \nМассив:\n";
	const int size1 = 5;
	int arr1[size1]{ 15, 5, 6, 7, 10 };
	for (int i = 0; i < size1; i++) {
		std::cout << arr1[i] << ' ';
	}
	std::cout << std::endl;
	
	int sum;
	psumarr(arr1, size1, &sum);
	std::cout << "Сумма элиментов массива равна = " << sum << std:: endl;

	return 0;
}

void psumarr(int arr[], const int lenght, int* var) {
	*var = 0;
	for (int i = 0; i < lenght; i++) {
		*var += arr[i];
	}
}